JS中的值有两种类型：原始类型(Primitive)、对象类型(Object)。
基本类型包括：Undefined、Null、Boolean、Number和String等五种。
Undefined类型和Null类型的都只有一个值，即undefined和null；
Boolean类型有两个值：true和false；Number类型的值有很多很多；
String类型的值理论上有无数个。
所有对象都有valueOf()和toString()方法，它们继承自Object，当然也可能被子类重写。

x == y
其中x和y是上述六种类型中某一种类型的值。
当x和y的类型相同时，x == y可以转化为x === y，而后者是很简单的(唯一需要注意的可能是NaN)，所以下面我们只考虑x和y的类型不同的情况。

一. 有和无
String、Number、Boolean和Object (对应左侧的大矩形框)
Undefined和Null (对应右侧的矩形框)
分组的依据是，右侧的Undefined和Null是用来表示不确定、无或者空的，而右侧的四种类型都是确定的、有和非空。我们可以这样说：
左侧是一个存在的世界，右侧是一个空的世界。
所以，左右两个世界中的任意值做==比较的结果都是false是很合理的。

二. 空和空
JavaScript中的undefined和null是另一个经常让我们崩溃的地方。通常它被认为是一个设计缺陷，这一点我们不去深究。
不管怎么样, undefined == null (true)都是事实

三. 真与假
当布尔值与其他类型的值作比较时，布尔值会转化为数字，具体来说
true -> 1    false -> 0

四. 字符的序列
在六种类型中，String和Number都是字符的序列(至少在字面上如此)。字符串是所有合法的字符的序列，而数字可以看成是符合特定条件的字符的序列。
所以，数字可以看成字符串的一个子集。
在字符串和数字做==运算时，需要使用ToNumber操作，把字符串转化为数字。假设x是字符串，y是数字，那么：x == y -> Number(x) == y;
字符串转化为数字的规则是规范中描述得很复杂，但是大致说来，就是把字符串两边的空白字符去掉，然后把两边的引号去掉，看它能否组成一个合法的数字。
如果是，转化结果就是这个数字；否则，结果是NaN。
例如：Number('123') // 结果123Number('1.2e3') // 结果1200Number('123abc') // 结果NaNNumber('\r\n\t123\v\f') // 结果123

当然也有例外，比如空白字符串转化为数字的结果是0。即
Number('') // 结果0Number('\r\n\t \v\f') // 结果0

五. 单纯与复杂
原始类型是一种单纯的类型，它们直接了当、容易理解。然而缺点是表达能力有限，难以扩展，所以就有了对象。对象是属性的集合，而属性本身又可以是对象。所以对象可以被构造得任意复杂，足以表示各种各样的事物。
但是，有时候事情复杂了也不是好事。比如一篇冗长的论文，并不是每个人都有时间、有耐心或有必要从头到尾读一遍，通常只了解其中心思想就够了。于是论文就有了关键字、概述。JavaScript中的对象也一样，我们需要有一种手段了解它的主要特征，于是对象就有了toString()和valueOf()方法。

toString()方法用来得到对象的一段文字描述；而valueOf()方法用来得到对象的特征值。
顾名思义，toString()方法倾向于返回一个字符串。valueof倾向于返回一个数字——尽管内置类型中，valueOf()方法返回数字的只有Number和Date。

当一个对象与一个非对象比较时，需要将对象转化为原始类型(虽然与布尔类型比较时，需要先将布尔类型变成数字类型，但是接下来还是要将对象类型变成原始类型)。这也是合理的，毕竟==是不严格的相等比较，我们只需要取出对象的主要特征来参与运算，次要特征放在一边就行了。

六. 万物皆数
在运算过程中，所有类型的值都有一种向数字类型转化的趋势。

总结一下:
undefined == null，结果是true。且它俩与所有其他值比较的结果都是false。
String == Boolean，需要两个操作数同时转为Number。
String/Boolean == Number，需要String/Boolean转为Number。
Object == Primitive，需要Object转为Primitive(具体通过valueOf和toString方法)。
